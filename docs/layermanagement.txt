
Layer Management Class
======================

Overview:
---------

Currently Marble is already capable of visualizing different kinds of information based on different rendering classes which paint onto the map canvas. These classes apply texture mapping, they add placemarks, they create vectors and apply effects (e.g. colorizing textures, shading) to the resulting images. There are also classes which create items that display information or add controls on top of the whole map, called "floating items" (e.g. compass, scale bar, planned: overview world map, on-map navigation control ).

However the whole process of rendering using those classes is hardcoded and not very flexible.

The Layer Management Class ("LMC") is supposed to solve this issue. In short the new LMC concept aims to:

- Create a QTPLUGIN (type: Lower-Level-API) architecture for the rendering process. 
- The backend functionality of the current rendering classes should go into BACKEND PLUGINS.
- The backend classes should be QT-THREAD-based.
- The backend classes should encourage the Model-View concept and make use of Qt's INTERVIEW framework.
- It should be possible to instantiate each backend class multiple times resulting in multiple layers.

Note that we distinguish between "BACKEND"-classes and the objects based on the BACKEND-classes called "LAYERS". 

- Due to different usage and technical requirements layers might either be
	a) SCREEN LAYERS (i.e. they don't care about the projection and are layers "on top of the screen"
	b) PROJECTION-BASED LAYERS (i.e. they get applied on top of the globe using the respective projection transformations).
	
- "Execution order" of the different backends should be based on the following mechanisms:
	a) each backend should provide "hardcoded" hints which describe dependencies (e.g. the texture colorization depends on the result of a texturemapping backend ) and allowed ranges for the rendering order (e.g. floating items should always be displayed on top of the map,  a starry background needs to get drawn before the globe is painted)
	b) the layermanagement class needs to fetch information from the .dgml-parser about the different types of backends that get used in a map. The .dgml file also needs to provide information about the rendering order.
	c) for backend types where there are no hard requirements on the rendering order the LMC should decide itself which order to take.

- According to the concept described so far it should be possible to paint different layers based on the very same backend  directly on top of each other (e.g. a cloud layer on top of a satellite map layer. This would result in two different layers. However for reasons of performance it needs to be possible to merge the data into a single layer ("MergedLayer"). 
This gets already done for placemarks where data from different files gets merged into a single file. It also gets done already for clouds on top of the satellite image data. However what's missing is a more generic approach where a MergedLayerPainter class operates directly on the tiles based on the information it receives from the LMC. Before telling the MergedLayerPainter class which layers need to get painted on top of the tiles the LMC needs to check whether tiles or sourceimage data is available for the map. If there is no such data available the LMC needs to either notify the TileLoader that it needs to create tiles or the LMC will simply ignore the missing data and will skip asking the MergedLayerPainter to render the missing data. 

- The plugin-backend concept should allow CUSTOM BACKENDS created by third party developers. 
- Creating new geographical features on the map should happen using a Qt-like API (which would include the QPainter API to draw in screen coordinates):

Code snippet:

	GeoPainter painter( mapCanvasImage, viewParams );
	painter.setPen( Qt::red );

	GeoDataPoint here( 54.8, 9.4, GeoDataPoint::Degree );
	GeoDataPoint there( 52.5, 8.4, GeoDataPoint::Degree );

	painter.drawGeoLine( here, there );
	painter.drawGeoPlacemark( "Flensburg", here );
	painter.drawGeoEllipse( here.lon(), here.lat(), 5, 5 ); 
	

- It should be possible to use this Qt-like Geo-API either from outside the MarbleWidget or from inside the custom backend plugin.


FUTURE low-priority enhancements (for usage in "real" light GIS apps that might use Marble in the future):

- Make it possible to specify custom changes to the rendering order of the layers using the LMC-API.
- Make it possible to create layer groups. This would e.g. enable the user to show/hide many "grouped" layers at once.


I. DGML SYNTAX FOR LAYERS:
==========================

The new DGML format has got three main sections:
1. The HEAD section in which basic properties get defined. 
2. The MAP section in which the layer structure gets defined. 
3. The LEGEND section in which custom legend elements get defined ( to be done in the future: the whole legend should get defined here )

The order inside the map section follows the rendering process:

1.) The rendering order starts at some distant point ( z = -infinity ) behind earth and approaches the observer until it reaches the globe. Obviously this range is only relevant for projections similar to the spherical one.
2.) Then the rendering order continues projection based from the surface up into the lower atmosphere.
3.) At last all layers between the earth's orbit (satellites!) up to the observer get rendered (z > 0).


EXAMPLE 1 : ATLAS ( filename: srtm.dgml )
-----------------------------------------


<?xml version="1.2" encoding="UTF-8"?>
<DeskGlobeML xmlns="http://edu.kde.org/marble/dgml/1.2">
<head>
	<name>Atlas</name>

	<prefix>srtm</prefix>
	<icon>srtm-preview.png</icon>

	<description>A classic topographic map. It uses vector lines to mark coastlines, country borders etc. and bitmap graphics to create the height relief.</description>

	<minimumzoom>  900 </minimumzoom>
	<maximumzoom> 2100 </maximumzoom>
</head>
	<!-- Now we create the layer structure that gets handled by the layer management class -->
<map>
	</canvas>
	<!-- In this place one could e.g. insert a sky plugin -->
	</earth>

	<!-- This layer creates the elevation model -->
	<layer name="srtm" plugin="texture"  type="dem">
		<sourcedir install=srtm.jpg> srtm <sourcedir>
		<!-- If this was the satellite map we could add another sourcedir 
	             tag for the clouds here resulting in a MergedLayer -->
	</layer>
	
	<!-- This layer creates the coastlines that are needed to colorize the elevation model properly -->
	<layer name="mwdbii" plugin="vector" type="filterhelper">
		<sourcefile name="pcoast"      format="PNT" category="land"> PCOAST.PNT </sourcefile>
		<sourcefile name="pisland"     format="PNT" category="land"> PISLAND.PNT </sourcefile>
		<sourcefile name="plakeisland" format="PNT" category="land"> PLAKEISLAND.PNT </sourcefile>
		<sourcefile name="plake"       format="PNT" category="sea">  PLAKE.PNT </sourcefile>
		<sourcefile name="pglacier"    format="PNT" category="sea">  PGLACIER.PNT </sourcefile>
	</layer>

	<!-- This layer provides the colorization -->
	<layer name="" plugin="filter" type="colorize">
		<dem>srtm</dem>
		<coastline>mwdbii<coastline>
		<!-- If these don't get defined the default palettes get used -->
		<palette type="sea">seapalette.pal</palette>
		<palette type="land">landpalette.pal</palette>
	<layer>

	<layer name="mwdbii" plugin="vector" type="feature">
		<sourcefile name="pdiffborder" format="PNT" category="border"   color="#f29b68">PDIFFBORDER.PNT</sourcefile>
		<sourcefile name="pusa48.diff" format="PNT" category="border"   color="#f29b68">PUSA48.DIFF.PNT</sourcefile>
		<sourcefile name="dateline"    format="PNT" category="timezone" color="#000000">DATELINE.PNT</sourcefile>
		<sourcefile name="priver.diff" format="PNT" category="river"    color="#637bff">PUSA48.DIFF.PNT</sourcefile>
	</layer>

	<layer name="places" plugin="placemarks">
		<sourcefile name="cityplacemarks"     format="KML">cityplacemarks.kml</sourcefile>
		<sourcefile name="baseplacemarks"     format="KML">baseplacemarks.kml</sourcefile>
		<sourcefile name="elevplacemarks"     format="KML">elevplacemarks</sourcefile>
		<sourcefile name="otherplacemarks"    format="KML">otherplacemarks</sourcefile>
		<sourcefile name="boundaryplacemarks" format="KML">boundaryplacemarks</sourcefile>
	</layer>

	<!-- Here we could e.g. add an atmosphere or satellite layer -->

	</layer name="floatitems" plugins="floatitems">
</map>

	<!-- At last we define some legend properties -->
<legend>
	<heading>Elevation</heading>
	<legenditem>
		<!-- For now integrating legend item symbols using pixmaps should be enough -->
		<itemsymbol><img src="topography_7000.png"></itemsymbol>
		<itemtext>7000 m</itemtext>
	</legenditem>
	<legenditem>
		<itemsymbol><img src="topography_5000.png"></itemsymbol>
		<itemtext>5000 m</itemtext>
	</legenditem>
	<!-- Insert further legend items here -->
</legend>
</DeskGlobeML>

