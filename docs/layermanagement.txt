
Layer Management Class
======================

Overview:
---------

Currently Marble is already capable of visualizing different kinds of
information based on different rendering classes which paint onto the
map canvas.

These classes:
 - apply texture mapping
 - and apply effects (e.g. colorizing textures, shading) to the
   resulting images.
 - add placemarks,
 - create vectors

There are also classes which create items that display information or
add controls on top of the whole map, called "floating items"
(e.g. compass, scale bar, planned: overview world map, on-map
navigation control ).

However the whole process of rendering using those classes is
hardcoded and not very flexible.

The Layer Management Class ("LMC") is supposed to solve this issue. In
short the new LMC concept aims to:

- Create a QTPLUGIN (type: Lower-Level-API) architecture for the
  rendering process.

- The backend functionality of the current rendering classes should go
  into BACKEND PLUGINS.

- The backend classes should be QT-THREAD-based.

- The backend classes should encourage the Model-View concept and make
  use of Qt's INTERVIEW framework.

- It should be possible to instantiate each backend class multiple
  times resulting in multiple layers.

Note that we distinguish between "BACKEND"-classes and the objects
based on the BACKEND-classes called "LAYERS".

Due to different usage and technical requirements layers might either be:

  a) PROJECTION-BASED LAYERS (i.e. they get applied on top of the
     globe using the respective projection transformations).
	
  b) SCREEN LAYERS (i.e. they don't care about the projection and are
     layers "on top of the screen"

"Execution order" of the different backends should be based on the
following mechanisms:

  a) Each backend should provide "hardcoded" hints which describe
     dependencies (e.g. the texture colorization depends on the result
     of a texturemapping backend ) and allowed ranges for the
     rendering order (e.g. floating items should always be displayed
     on top of the map, a starry background needs to get drawn before
     the globe is painted)

  b) In Marble the structure of each map gets described in the map's
     .dgml file. So the layermanagement class needs to fetch
     information from the .dgml-parser about the different types of
     backends that get used in a map. The .dgml file also needs to
     provide information about the rendering order.

  c) For backend types where there are no hard requirements on the
     rendering order the LMC should decide itself which order to
     take. So if for example a custom backend-plugin doesn't get
     mentioned in the .dgml file the LMC should make a well-educated
     guess at which place inside the layer structure it would be best
     to insert the layer.

According to the concept described so far it should be possible to
paint different layers based on the very same backend directly on top
of each other (e.g. a cloud layer on top of a satellite map layer.
Normally this would result in two different layers.  However for
reasons of performance it needs to be possible to merge the data into
a single layer right from the start ("MergedLayer").

This gets already done for placemarks in current SVN where data from
different files gets merged into a single file. It also gets done
already for clouds on top of the satellite image data. However what's
missing is a more generic approach where a MergedLayerPainter class
operates directly on the tiles based on the information it receives
from the LMC.

Before telling the MergedLayerPainter class which layers need to get
painted on top of the tiles the LMC needs to check whether tiles or
sourceimage data is available for the map. If there is no such data
available the LMC needs to either notify the TileLoader that it needs
to create tiles or the LMC will simply ignore the missing data and
will skip asking the MergedLayerPainter to render the missing data.

- The plugin-backend concept should allow CUSTOM BACKENDS created by
  third party developers.

- Creating new geographical features on the map should happen using a
  Qt-like API (which would include the QPainter API to draw in screen
  coordinates):

  Code snippet:

	GeoPainter painter( mapCanvasImage, viewParams );
	painter.setPen( Qt::red );

	GeoDataPoint  place1( 54.8, 9.4, GeoDataPoint::Degree );
	GeoDataPoint  place2( 52.5, 8.4, GeoDataPoint::Degree );

	painter.drawGeoLine( place1, place2 );
	painter.drawGeoPlacemark( "Flensburg", place1 );
	painter.drawGeoEllipse( place1.lon(), place1.lat(), 5, 5 ); 
	

- It should be possible to use this Qt-style Geo-API either from
  outside the MarbleWidget or from inside the custom backend plugin.

- It should be possible to create custom PROPRIETARY PLUGINS which are
  able to provide PROPRIETARY DATA in a manner that prevents exporting
  the whole data at once.

  Yes, while we strongly believe in free maps and free data we would
  also like to see proprietary apps use our widget - as always patches
  sent to us under a free license are very much appreciated.

- Expiring layer data: The LMC should get notified about expiration
  dates of layer data. If layer data expires the LMC should trigger a
  reload of each chunk of data. Initially it would be enough if we
  supported reloading the whole data set of a single layer. In the
  future reloading single data chunks of a layer would be nice to
  have. (Examples for tile expiration: Real-time cloud layers,
  Improvements for OpenStreetMap data).

- LMC should also work fine with OpenGL-based backend-plugins.

FUTURE low-priority enhancements (for usage in "real" light GIS apps
that might use Marble in the future):

- Make it possible to specify custom changes to the rendering order of
  the layers using the LMC-API.

- Make it possible to create layer groups. This would e.g. enable the
  user to show/hide many "grouped" layers at once.


I. DGML SYNTAX FOR LAYERS:
==========================

Marble uses its own XML format called "DGML" to load and save maps.
The DGML map format describes the basic properties of a map. The format assumes that the map consists of data that gets imported and integrated from various data sources. So it's different from other map formats which try to describe all the features in a map themselves: DGML reuses existing map data from established file formats (e.g. KML, GPX, GeoRSS), arranges them in layers and compiles them together into a new map.


The new planned DGML format has got three main sections:

1. The HEAD section in which basic properties get defined.

2. The MAP section in which the layer structure gets defined. 

3. The LEGEND section in which custom legend elements get defined (to
   be done in the future: the whole legend should get defined here).

The order inside the map section follows the rendering process:

1.) The rendering order starts at some distant point ( z = -infinity )
    behind earth and approaches the observer until it reaches the
    globe. Obviously this range is only relevant for projections
    similar to the spherical one.

2.) Then the rendering order continues projection based from the
    surface up into the lower atmosphere.

3.) At last all layers between the earth's orbit (satellites!) up to
    the observer get rendered (z > 0).


EXAMPLE 1 : ATLAS ( filename: srtm.dgml )
-----------------------------------------


<?xml version="2.0" encoding="UTF-8"?>
<DeskGlobeML xmlns="http://edu.kde.org/marble/dgml/1.2">

    <head>
        <name>Atlas</name>
	    <prefix>srtm</prefix>
	    <icon>srtm-preview.png</icon>

        <!-- describes whether the map theme item will be hidden (e.g. for a clouds layer): -->
        <visible> true </visible>
    
        <!-- The description allows for rich text of course: -->
	    <description>A classic topographic map. It uses vector lines to mark coastlines, country borders etc. and bitmap graphics to create the height relief.</description>

        <zoom>
    	    <minimum>   900  </minimum>
    	    <maximum>  2100  </maximum>

            <!-- describes whether you can zoom trough the levels continuously -->
            <discrete> false </discrete> 
        </zoom>
    </head>
    
	    <!-- Now we create the layer structure that gets handled by the layer management class -->
    
    <map bgcolor="#000000">
	    </canvas>
	    <!-- In this place one could e.g. insert a sky plugin -->
	    </planet>
    
	    <!-- This layer creates the elevation model -->
	    <layer name="srtm" plugin="texture"  type="dem">
            <texture format="JPG" expire="10800">
                <sourcedir> srtm </sourcedir>
                <installmap> srtm.jpg </installmap>
            </texture>
		    <!-- If this was the satellite map we could add another texture 
	                tag for the clouds here resulting in a MergedLayer 
                Also note that for the tiles you can suggest a different 
                image format than for the original install image (e.g. "PNG").
                -->
	    </layer>
	    
	    <!-- This layer creates the coastlines that are needed to colorize the elevation model properly -->
	    <layer name="mwdbii" plugin="vector" type="filterhelper">
            <vector name="pcoast" type="land">
                <sourcefile format="PNT"> PCOAST.PNT </sourcefile>
            <vector>
            <vector name="pisland" type="land">
                <sourcefile format="PNT"> PISLAND.PNT </sourcefile>
            </vector>
            <vector name="plakeisland" type="land">
                <sourcefile format="PNT"> PLAKEISLAND.PNT </sourcefile>
            </vector>
            <vector name="plake" type="sea">
                <sourcefile format="PNT"> PLAKE.PNT </sourcefile>
            </vector>
            <vector name="pglacier" type="sea">
                <sourcefile format="PNT">  PGLACIER.PNT </sourcefile>
            </vector>
	    </layer>
    
	    <!-- This layer provides the colorization -->
	    <layer name="" plugin="filter">
            <filter name="texturecolorizer" type="colorize">
                <dem>srtm</dem>
                <coastline>mwdbii<coastline>
                <!-- If these don't get defined the default palettes get used -->
                <palette type="sea">seapalette.pal</palette>
                <palette type="land">landpalette.pal</palette>
            </filter>
	    <layer>
    
	    <layer name="mwdbii" plugin="vector" type="polyline">
            <vector name="pdiffborder" type="border">
                <sourcefile format="PNT">PDIFFBORDER.PNT</sourcefile>
                <color>#f29b68</color>
            </vector>
            <vector name="pusa48.diff" type="polyline">
		        <sourcefile format="PNT">PUSA48.DIFF.PNT</sourcefile>
                <color>#f29b68</color>
            </vector>
            <vector name="international dateline" type="polyline">
                <sourcefile format="PNT">DATELINE.PNT</sourcefile>
                <color>#000000</color>
            </vector>
            <vector name="pusa48" type="polyline">
                <sourcefile format="PNT">PUSA48.DIFF.PNT</sourcefile>
                <color>#637bff</color>
            </vector>
	    </layer>
    
	    <layer name="standardplaces" plugin="geodata">
            <geodata name="cityplacemarks">
                <sourcefile format="KML">cityplacemarks.kml</sourcefile>
                <pick>placemark<pick> <!-- picks certain features from a file -->
            </geodata>
            <geodata name="baseplacemarks">
                <sourcefile format="KML">baseplacemarks.kml</sourcefile>
                <pick>placemark<pick>
            </geodata>
            <geodata name="elevplacemarks">
                <sourcefile format="KML">elevplacemarks.kml</sourcefile>
                <pick>placemark<pick>
            </geodata>
            <geodata name="otherplacemarks">
                <sourcefile format="KML">otherplacemarks.kml</sourcefile>
                <pick>placemark<pick>
            </geodata>
            <geodata name="boundaryplacemarks">
                <sourcefile format="KML">boundaryplacemarks</sourcefile>
                <pick>placemark<pick>
            </geodata>
	    </layer>
    
        <layer name="helloworldlayer" plugin="helloworldplugin">
            <customplugin name="helloworld">
                <sourcefile format="JPG">helloworld.jpg</sourcefile>
            </customplugin>
        </layer>
    
	    <!-- Here we could e.g. add an atmosphere or satellite layer -->
    
	    </layer name="floatitems" plugins="floatitems">
    </map>
    
	<!-- At last we define some legend properties -->
    
    <legend>
        <section name="elevation" checkable="false" spacing="12">
            <heading>Elevation</heading>
            <!-- Example for a pixmap legend item: -->
            <item>
                <icon pixmap="topography_7000.png"/>
                <text>7000 m</text>
            </item>
            <!-- Example for a color gradient legend item: -->
            <item>
                <icon color="#dcbd80"/>
                <text>5000 m</text>
            </item>
            <!-- Example for a pixmap with a color as a translucent background: -->
            <item>
                <icon color="#f29b68" pixmap="boundary.png"/>
                <text>State Boundary</text>
            </item>
            <!-- Insert further legend items here -->
        </section>
    </legend>

</DeskGlobeML>

